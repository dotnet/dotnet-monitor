<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ErrorMessage_CredentialsMissing" xml:space="preserve">
    <value>The {0} field, {1} field, {2} field, or {3} field is required.</value>
    <comment>Gets the format string for rejecting validation due to 3 missing fields where at least one is required.
3 Format Parameters:
0. fieldNameOne: The name of the first field that is missing
1. fieldNameTwo: The name of the second field that is missing
2. fieldNameThree: The name of the third field that is missing
3. fieldNameFour: The name of the fourth field that is missing</comment>
  </data>
  <data name="ErrorMessage_EgressAzureFailedDetailed" xml:space="preserve">
    <value>Azure blob egress failed: {0}</value>
    <comment>Gets the format string for egress failure to Azure blob (with an inner message).
1 Format Parameter:
0. innerMessage: The detailed inner message with additional error context.</comment>
  </data>
  <data name="ErrorMessage_EgressAzureFailedGeneric" xml:space="preserve">
    <value>Azure blob egress failed.</value>
    <comment>Gets a string similar to "Azure blob egress failed.".</comment>
  </data>
  <data name="ErrorMessage_EgressMissingCredentials" xml:space="preserve">
    <value>SharedAccessSignature, AccountKey, ManagedIdentityClientId, or UseWorkloadIdentityFromEnvironment must be specified.</value>
    <comment>Gets a string similar to "SharedAccessSignature, AccountKey, ManagedIdentityClientId, or UseWorkflowIdentity must be specified.".</comment>
  </data>
  <data name="LogFormatString_DuplicateKeyInMetadata" xml:space="preserve">
    <value>Metadata cannot include duplicate keys; please change or remove the key '{key}'</value>
    <comment>Gets a string similar to "Metadata cannot include duplicate keys; please change or remove the key '{key}'".</comment>
  </data>
  <data name="LogFormatString_EgressCopyActionStreamToEgressStream" xml:space="preserve">
    <value>Copying action stream to egress stream with buffer size {bufferSize}</value>
    <comment>Gets the format string that is printed in the 5:EgressCopyActionStreamToEgressStream event.
1 Format Parameter:
1. bufferSize: Size of the buffer</comment>
  </data>
  <data name="LogFormatString_EgressProviderInvokeStreamAction" xml:space="preserve">
    <value>Provider {providerType}: Invoking stream action.</value>
    <comment>Gets the format string that is printed in the 11:EgressProviderInvokeStreamAction event.
1 Format Parameter:
1. providerType: Type of the provider that was invoked</comment>
  </data>
  <data name="LogFormatString_EgressProviderSavedStream" xml:space="preserve">
    <value>Provider {providerType}: Saved stream to {path}</value>
    <comment>Gets the format string that is printed in the 12:EgressProviderSavedStream event.
2 Format Parameters:
1. providerType: Type of the provider
2. path: path where provider saved the stream</comment>
  </data>
  <data name="LogFormatString_EgressProviderUnableToFindPropertyKey" xml:space="preserve">
    <value>Provider {providerType}: Unable to find '{keyName}' key in egress properties</value>
    <comment>Gets the format string that is printed in the 10:EgressProviderUnableToFindPropertyKey event.
2 Format Parameters:
1. providerType: Type of the provider
2. keyName: Name of the property that could not be found</comment>
  </data>
  <data name="LogFormatString_EnvironmentBlockNotSupported" xml:space="preserve">
    <value>Target framework does not support custom egress metadata.</value>
  </data>
  <data name="LogFormatString_EnvironmentVariableNotFound" xml:space="preserve">
    <value>The environment variable '{name}' could not be found on the target process.</value>
    <comment>Gets a string similar to "The environment variable '{name}' could not be found on the target process.".</comment>
  </data>
  <data name="LogFormatString_InvalidMetadata" xml:space="preserve">
    <value>Invalid metadata; custom metadata keys must be valid C# identifiers.</value>
    <comment>Gets a string similar to "Invalid metadata; custom metadata keys must be valid C# identifiers.".</comment>
  </data>
  <data name="LogFormatString_QueueDoesNotExist" xml:space="preserve">
    <value>The queue {0} does not exist; ensure that the {queueName} and {queueAccountUri} fields are set correctly.</value>
    <comment>Gets the format string that is printed in the 57:QueueDoesNotExist event.
3 Format Parameters:
1. queueName: The name of the Azure Queue where messages are egressed
2. nameof(queueName)
3. nameof(queueAccountUri)</comment>
  </data>
  <data name="LogFormatString_QueueOptionsPartiallySet" xml:space="preserve">
    <value>Queue message egress requires {queueName} and {queueAccountUri} to be set</value>
    <comment>Gets the format string that is printed in the 58:QueueOptions event.
2 Format Parameters:
1. nameof(queueName)
2. nameof(queueAccountUri)</comment>
  </data>
  <data name="LogFormatString_WritingMessageToQueueFailed" xml:space="preserve">
    <value>Unable to send message to the queue {0}.</value>
    <comment>Gets the format string that is printed in the 59:WritingMessageToQueueFailed event.
1 Format Parameter:
1. queueName: The name of the Azure Queue where messages are egressed</comment>
  </data>
</root>
