<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>$(ToolTargetFramework)</TargetFramework>
    <RootNamespace>Microsoft.Diagnostics.Tools.Monitor</RootNamespace>
    <ToolCommandName>dotnet-monitor</ToolCommandName>
    <Description>.NET Core Diagnostic Monitoring Tool</Description>
    <PackageTags>Diagnostic</PackageTags>
    <PackageReleaseNotes>$(Description)</PackageReleaseNotes>
    <ServerGarbageCollection>false</ServerGarbageCollection>
    <OpenApiGenerateDocuments>false</OpenApiGenerateDocuments>
    <Nullable>enable</Nullable>
    <EnableConfigurationBindingGenerator>false</EnableConfigurationBindingGenerator>
    <DisableCompileTimeOpenApiXmlGenerator>true</DisableCompileTimeOpenApiXmlGenerator>
    <!-- This repo sets RuntimeIdentifiers globally in Directory.Build.props, but we explicitly don't want to use
         RID-specific tools yet. So we need to clear the RuntimeIdentifiers here. -->
    <RuntimeIdentifiers Condition="'$(_IsPacking)' == 'true'"></RuntimeIdentifiers>
    <!-- This doesn't work as a way to override the set of package identifiers (yet) because in MSBuild logic we
         can't detect the difference between property-set-to-empty and property-does-not-exist.
         See https://github.com/dotnet/msbuild/issues/12404 for tracking. -->
    <ToolPackageRuntimeIdentifiers></ToolPackageRuntimeIdentifiers>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.Negotiate" />
    <PackageReference Include="Microsoft.Identity.Web" />
    <PackageReference Include="System.CommandLine" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" GeneratePathProperty="true" />
  </ItemGroup>

  <ItemGroup Condition="'$(DIAGNOSTICS_REPO_ROOT)' == ''">
    <PackageReference Include="Microsoft.Diagnostics.Monitoring" />
  </ItemGroup>

  <ItemGroup Condition="'$(DIAGNOSTICS_REPO_ROOT)' != ''">
    <ProjectReference Include="$(DIAGNOSTICS_REPO_ROOT)\src\Microsoft.Diagnostics.Monitoring\Microsoft.Diagnostics.Monitoring.csproj" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Microsoft.Diagnostics.Monitoring.Options\Microsoft.Diagnostics.Monitoring.Options.csproj" />
    <ProjectReference Include="..\..\Microsoft.Diagnostics.Monitoring.WebApi\Microsoft.Diagnostics.Monitoring.WebApi.csproj" />
  </ItemGroup>

  <ItemGroup>
    <InternalsVisibleTo Include="Microsoft.Diagnostics.Monitoring.ConfigurationSchema" />
    <InternalsVisibleTo Include="Microsoft.Diagnostics.Monitoring.OpenApiGen" />
    <InternalsVisibleTo Include="CollectionRuleActions.UnitTests" />
    <InternalsVisibleTo Include="Microsoft.Diagnostics.Monitoring.Tool.TestHostingStartup" />
    <InternalsVisibleTo Include="Microsoft.Diagnostics.Monitoring.Tool.UnitTestCommon" />
    <InternalsVisibleTo Include="Microsoft.Diagnostics.Monitoring.Tool.UnitTests" />
    <InternalsVisibleTo Include="$(MoqInternalsVisibleTo)" Key="$(MoqInternalsVisibleToKey)" />
  </ItemGroup>

  <ItemGroup>
    <Compile Update="Strings.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Strings.resx</DependentUpon>
    </Compile>
    <EmbeddedResource Update="Strings.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Strings.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

  <Target Name="EmbedWebApiXmlDocumentation"
          DependsOnTargets="ResolveAssemblyReferences"
          BeforeTargets="AssignTargetPaths">
    <MSBuild Projects="..\..\Microsoft.Diagnostics.Monitoring.WebApi\Microsoft.Diagnostics.Monitoring.WebApi.csproj"
             Properties="TargetFramework=$(TargetFramework)"
             RemoveProperties="RuntimeIdentifier"
             Targets="GetDocumentationFile">
      <Output ItemName="_WebApiDocumentationFiles" TaskParameter="TargetOutputs" />
    </MSBuild>
    <!-- Add the WebApi documentation file as an embedded resource. -->
    <ItemGroup>
      <EmbeddedResource Include="@(_WebApiDocumentationFiles)">
        <LogicalName>%(Filename)%(Extension)</LogicalName>
      </EmbeddedResource>
    </ItemGroup>
  </Target>

  <!-- Targets and properties for ensuring publish before pack. -->
  <Import Project="$(RepoRoot)src\archives\AzureBlobStorage\ProjectsToPublish.props" />
  <Import Project="$(RepoRoot)src\archives\S3Storage\ProjectsToPublish.props" />
  <Import Project="$(RepoRoot)src\Microsoft.Diagnostics.Monitoring.StartupHook\ProjectsToPublish.props" />
  <Import Project="$(RepositoryEngineeringDir)PublishProjects.targets" />

  <ItemGroup Label="Computed Publish Assets">
    <!-- Pack the profiler library for each platform. -->
    <AdditionalRIDSpecificPublishFile
      Include="@(MonitorProfilerLibraryFile);
               @(MutatingMonitorProfilerLibraryFile);
               @(MonitorProfilerSymbolsFile);
               @(MutatingMonitorProfilerSymbolsFile);
               @(CommonMonitorProfilerSymbolsFile);
              ">
        <RelativePath>shared/%(TargetRid)/native/%(Filename)%(Extension)</RelativePath>
     </AdditionalRIDSpecificPublishFile>

     <!-- Pack startup hook files -->
     <AdditionalRIDAgnosticPublishFile Include="$(StartupHookLibraryPath);$(StartupHookSymbolsPath)">
       <RelativePath>shared/any/$(StartupHookTargetFramework)/%(FileName)%(Extension)</RelativePath>
     </AdditionalRIDAgnosticPublishFile>

     <!-- Pack extension files -->
     <AdditionalRIDAgnosticPublishFile Include="$(AzureBlobStoragePublishRootPath)$(TargetFramework)\any\**">
       <RelativePath>extensions/$(AzureBlobStorageExtensionFolderName)/%(RecursiveDir)%(FileName)%(Extension)</RelativePath>
     </AdditionalRIDAgnosticPublishFile>
     <AdditionalRIDAgnosticPublishFile Include="$(S3StoragePublishRootPath)$(TargetFramework)\any\**">
       <RelativePath>extensions/$(S3StorageExtensionFolderName)/%(RecursiveDir)%(FileName)%(Extension)</RelativePath>
     </AdditionalRIDAgnosticPublishFile>
  </ItemGroup>

  <Target Name="AddNativeAssetsToPublishLayout"
          BeforeTargets="ComputeResolvedFilesToPublishList">
    <ItemGroup>
      <ResolvedFileToPublish Include="@(AdditionalRIDSpecificPublishFile->Exists());@(AdditionalRIDAgnosticPublishFile)">
        <CopyFileToPublishDirectory>PreserveNewest</CopyFileToPublishDirectory>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>

</Project>
